---
title: "Visualizations"
---

## Introduction {#sec-intro-viz}

Whoever said a picture is worth 1,000 words severely understated how many words a picture is actually worth. When working with data, there is a strong argument to make that **nothing** is more important than visuals.

::: {.callout-tip}
## If there is one piece of advice to take from this textbook, it is this:
After running summary statistics, always visualize your data!
:::

You may be thinking "how powerful can a visualization even be?" That is a great question, that Anscombeâ€™s quartet will help answer.

Quick history lesson. In 1973 (before the invention of R), a statistician named Francis Anscombe created four unique datasets, which all had identical summary statistics.

```{r}
#| label: tbl-anscombe
#| message: FALSE
#| warning: FALSE
library(tidyverse)
library(quartets)
library(knitr)

anscombe_quartet %>%
  group_by(dataset) %>%
  summarise(mean_x = mean(x),
            variance_x = var(x),
            mean_y = mean(y),
            variance_y = var(y),
            correlation = cor(x, y)) %>%
  kable(digits = 2,caption = "A breakdown of summary statistics from the four individual datasets Anscombe created.")
```

As @tbl-anscombe shows, all four of the different datasets show the same means, variances, and correlations (more on that in chapter 6). With *just* these summary statistics, you'd likely think "eh, all the data is the same, these datasets are basically identical."

**Wrong.**

When we graph these four datasets, we see something totally different than what the table shows.

```{r}
#| label: fig-Anscombe-graph
#| fig-cap: "While the four datasets looked identical in the table, the visualized Anscombe datasets show an entirely different picture."
ggplot(anscombe_quartet, aes(x = x, y = y)) +
  geom_point() + 
  geom_smooth(method = "lm") +
  facet_wrap(~dataset)
```

With our visualization, we are introduced to an entirely different way of seeing our data. The table showed that the summary statistics were identical, but here we can see:

1.  Dataset One has a linear relationship between x and y.
2.  Dataset Two has a nonlinear relationship between x and y.
3.  Dataset Three, while still linear, has an outlier.
4.  Dataset Four shows something totally different from the rest!

Visualizations provide insights into data that sometimes numbers can't show.

This chapter is meant less to be a lesson, and more to be a reference page to come to when you need to make graphs. You do not need to remember every plotting option shown here. This chapter is designed to be returned to whenever you need a reminder or example.

## Learning Objectives {#sec-viz-objectives}

By the end of this chapter, you will be able to:

-   Explain why visualizing data is a critical step alongside summary statistics
-   Describe the core grammar of graphics used by `ggplot2` (data, aesthetics, geometry)
-   Create common plot types using `ggplot2`, including scatterplots, bar charts, column charts, histograms, density plots, boxplots, and line graphs
-   Map and customize aesthetics such as color, shape, size, fill, and transparency
-   Enhance visual clarity using labels, themes, facets, coordinate transformations, and reference lines
-   Add contextual information to plots using trend lines, error bars, and text labels
-   Interpret visual patterns to identify relationships, distributions, outliers, and trends in data
-   Create visualizations that are interpretable and reproducible when viewed independently of accompanying text

With that being said, let's get right to it.

## Base R {#sec-viz-base-r}

One of the strongest qualities in R is its ability to create visualizations, powered by `ggplot2`. However, it is possible to use base R to create plots as well. It is recommended to use ggplot2; however, you may encounter base R plots in older scripts or documentation, so an example is included for familiarity.

```{r}
#| label: fig-baseR-plot
#| fig-cap: "An example of a bar chart created using base R."
values <- c(100, 17, 45, 55, 44)

barplot(values, xlab = "X-axis", ylab = "Y-axis", main ="Base R Bar Chart")
```

## ggplot2 {#sec-ggplot}

Before we go into visualizing our data, we should probably see what data we will be working with! Similar to how R comes preinstalled with datasets, `ggplot2` also comes with prepacked data that can be utilized.

```{r}
#| label: tbl-mpg-kable
#| message: FALSE
#| warning: FALSE
kable(head(mpg), caption = "A base R dataset: Fuel economy data from 1999 to 2008 for 38 popular models of cars.")
```

```{r}
#| label: tbl-economics-kable
kable(head(economics), caption = "A base R dataset: US Economic Time Series.")
```

```{r}
#| label: tbl-diamonds-kable
kable(head(diamonds), caption = "A base R dataset: Prices of over 50,000 round cut diamonds.")
```

```{r}
#| label: tbl-mtcars-kable
kable(head(mtcars), caption = "A base R dataset: Motor Trend Car Road Tests.")
```

Additionally, `ggplot2` is part of the `tidyverse` package. So, you can either load `ggplot2` or `tidyverse` if you want to visualize using `ggplot2`. Because `ggplot2` is part of the `tidyverse`, everything you learned in Chapter @sec-intro-tidyverse about pipelines and data manipulation carries directly into visualizations.

### Basics {#sec-ggplot-basics}

When using `ggplot2`, there are unlimited possibilities on what you can manipulate/influence. This may be daunting, but always remember that all plots work on the same framework.

::: {.callout-tip}
## ggplot2 framework
plot = data + aesthetics + geometry
:::

No matter what ggplot you are making, no matter how many characteristics you influence, all ggplot2 needs are three things:

1.  The data: the data being used to make the plot
2.  The aesthetics: x/y/color/shape/etc. In `ggplot2` aesthetics is shortened to aes.
3.  The geometry: plot type (e.g., scatterplot, boxplot, etc.)

With only those three things, you can make **any** type of visualization you want or need. From there, you can build as far as your mind can see. When you do want to add more levels to your plot, you do so by using the + sign.

Here is an example of a basic graph made with ggplot:

```{r}
#| label: fig-example-ggplot2
#| fig-cap: "An example of a visualization made using ggplot2."
ggplot(data = mpg, aes(x = cty, y = hwy)) +
  geom_point()
```

This is our first ggplot (a scatterplot) we have created, so let's break this down:

-   The data: we are using the mpg dataset.
-   The aesthetics: the x variable is cty and the y is hwy.
-   The geometry: `geom_point()`, which creates points on the graph.
    -   Importantly, to add geometry, you do need to add the + sign.

With only two lines of code, a scatterplot was created! Since the framework has been established, it is time to build some visualizations!

:::{.callout-note}
## How to move on from here:
In this chapter, there will be basic examples of each visualization type, and advanced examples of each visualization type. This is done to display the scope of what can be done with this package (`ggplot2`). It is encouraged to experiment with the code, change numbers, remove things, and compare and contrast the differences between the experimented visuals.
:::

### Scatterplot - geom_point() {#sec-ggplot-scatterplot}

When data has two continuous (for example, numeric) variables, and you want to visualize their relationship, a scatterplot is a fantastic choice. This is the basis for relationship analysis that topics such as linear regression (more about this in Chapter @sec-linear-reg) rely on.

The geometry that needs to be specified is `geom_point()`.

```{r}
#| label: fig-basic-scatterplot
#| fig-cap: "A basic example of a scatterplot using ggplot2."
ggplot(data = mpg, aes(x = cty, y = hwy)) +
  geom_point()
```

Typically it is best practice to have a "line of best fit" when creating scatterplots, similar to Anscombe's visualization. To do that, you can utilize the `geom_smooth()` command.

```{r}
#| label: fig-ggplot2-scatterplot-lm
#| fig-cap: "An example of a scatterplot with a line of best fit."
# Line of Best Fit
ggplot(mpg, aes(x = cty, y = hwy)) +
  geom_point() +
  geom_smooth(method = "lm") # lm stands for "linear model"
```

Notice that to add `geom_smooth`, which is another layer of our visualization, we needed to add another + sign. It is used quite literally in `ggplot2`.

Let's add some more information to our scatterplot.

```{r}
#| label: fig-scatterplot-advanced
#| fig-cap: "A scatterplot incorporating multiple aesthetics and faceting."
ggplot(data = mpg, aes(x = cty, y = hwy, color = class, shape = drv)) +
  geom_point(alpha = 0.8, size = 2.5) + # opacity and size
  labs(
    title = "City vs Highway MPG",      # adds a title to the plot
    x = "City MPG",                     # adds a x-axis label to the plot
    y = "Highway MPG",                  # adds a y-axis label to the plot
    color = "Vehicle Class",            # adds a color label to the plot
    shape = "Drivetrain"                # adds a shape label to the plot
  ) + 
  facet_wrap(~ class) +                 # breaks the graph into individual graphs
  geom_smooth(method = "lm", se = TRUE) # adds a line of best fit
```

### Bar Chart (counts) and Column Chart (values) {#sec-ggplot-bar-column}

Bar charts visualize counts of a discrete variable, while column charts visualize pre-summarized numeric values.

#### Bar Chart - geom_bar() {#sec-ggplot-bar}

For a bar chart, the geometry used is `geom_bar()`.

```{r}
#| label: fig-basic-barchart
#| fig-cap: "An example of a basic bar chart."
# BASIC (counts by class) - geom_bar() counts rows automatically
ggplot(mpg, aes(x = class)) +
  geom_bar()
```

Depending on how long the variable names are, it may be best to switch the x and y axis. They would still **act** the same, but they would just flip on the coordinate plane. The x variable would still be the x variable, and the y would still be the y variable, but flipped. To do this, you can utilize the `coord_flip()` command.

```{r}
#| label: fig-barplot-coordflip
#| fig-cap: "An example of a coordinate flipped bar chart."
ggplot(mpg, aes(x = manufacturer)) +
  geom_bar(fill = "steelblue", color = "white") +
  coord_flip() +
  labs(title = "Counts by Manufacturer", x = "", y = "Count")
```

Depending on the audience, a stacked bar chart may be the best way to visualize the data. To do that, you can add `position = "stack"` and `ggplot` does the rest.

```{r}
#| label: fig-stacked-barchart-example
#| fig-cap: "An example of a stacked bar chart."
# What if we want a stacked bar chart (default with fill)?
ggplot(mpg, aes(x = manufacturer, fill = drv)) +
  geom_bar(position = "stack", color = "white") +
  coord_flip() +
  labs(
    title = "Counts by Manufacturer and Drivetrain",
    x = "",
    y = "Count",
    fill = "Drivetrain"
  ) +
  theme_minimal()
```

If you need to create a grouped bar chart instead, you can add `position = "dodge"` to create your visual.

```{r}
#| label: fig-grouped-barchart
#| fig-cap: "An example of a grouped bar chart."
#What if we want a grouped bar chart
ggplot(mpg, aes(x = manufacturer, fill = drv)) +
  geom_bar(position = "dodge", color = "white") +
  coord_flip() +
  labs(
    title = "Counts by Manufacturer and Drivetrain",
    x = "",
    y = "Count",
    fill = "Drivetrain"
  ) +
  theme_minimal()
```

#### Column Chart - geom_col() {#sec-ggplot-column}

Column charts work best when you have pre-summarized values, and not raw values.

```{r}
#| label: tbl-pre-summarizing-values
# USING PRE-SUMMARIZED VALUES - geom_col() requires explicit values
class_counts <- mpg %>%
  count(class)  # counts rows by class

kable(class_counts, caption = "Pre-summarized values")
```

Once the values have been summarized explicitly, you use `geom_col()` to create a column chart.

```{r}
#| label: fig-basic-columnchart
#| fig-cap: "An example of a basic column chart." 
ggplot(class_counts, aes(x = class, y = n)) +
  geom_col()
```

There are a few things you can do to a column chart to add some flavor. For example:

-   Use the `reorder` command to reorder the columns into ascending or descending order based on their n values.
-   Inside of `geom_col` change the `width` of the columns.
-   Depending on the bars, you can change the `legend.position` to a particular spot (or remove it entirely) from the visualization.

```{r}
#| label: fig-columnchart-aesthetics
#| fig-cap: "An example of a column chart with polished aesthetics."
# PLUS AESTHETICS (polished)
ggplot(class_counts, aes(x = reorder(class, n), y = n, fill = class)) +
  geom_col(width = 0.7, color = "white") +   # width = bar thickness, color = border
  coord_flip() +                             # flip for readability
  labs(title = "Counts by Vehicle Class", x = "", y = "Count") +
  theme(legend.position = "none")
```

::: {.callout-note}
## Legends in a graph and redundancy.
Sometimes having a legend in a graph can be redundant because of the x-axis containing the same information as a legend would. In this case, you can remove the legend not only to avoid the redundancy, but also save space.
:::

### Histograms and Density Plots (distribution) {#sec-ggplot-histogram-density}

Histograms are perfect for when you are looking to display **distribution**.

#### Histograms - geom_histogram() {#sec-ggplot-histogram}

For the geometry of a histogram, you use `geom_histogram()`.

```{r}
#| label: fig-basic-histogram
#| fig-cap: "An example of a basic histogram."
# BASIC
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(binwidth = 3)
```

R automatically assigns bins when creating a histogram unless otherwise instructed. There are several things that can be influenced:

-   bin width: use `binwidth` to change the width of the bins
-   boundary: use `boundary` to set the separation between the bins

```{r}
#| label: fig-styled-histogram
#| fig-cap: "An example of a styled histogram."
# STYLED (bin edges + colors)
ggplot(mpg, aes(hwy)) +
  geom_histogram(binwidth = 5, boundary = 0,
                 fill = "red", color = "orange") +
  labs(title = "Highway MPG Distribution", x = "Highway MPG", y = "Frequency")
```

In the case that you need a stacked histogram, below is code to create that. The secret here is using the `fill` command.

```{r}
#| label: fig-filled-histogram
#| fig-cap: "An example of a filled histogram."
# MAPPED FILL (stacked by class)
ggplot(mpg, aes(hwy, fill = class)) +
  geom_histogram(binwidth = 10, color = "white") +
  labs(title = "Highway MPG Distribution by Vehicle Class",
       x = "Highway MPG", y = "Count", fill = "Vehicle Class") +
  theme(legend.position = "bottom")
```

#### Density - geom_density() {#sec-ggplot-density}

Density plots still show the distribution of data, but instead of doing it in bins like a histogram, accomplish this through an **outline**. The geometry for a density plot is `geom_density()`.

```{r}
#| label: fig-basic-densityplot
#| fig-cap: "An example of a basic density plot."
# BASIC
ggplot(diamonds, aes(x = price)) +
  geom_density()
```

In the below example, the visualization is filtering within the data portion to only keep the cuts "Good", "Ideal" and "Premium." Since it is utilizing `color` inside the aesthetics, this will create a grouped density plot, showing three different lines for each of the three different cuts.

:::{.callout-note}
##Regarding the data portion of the graph below:
If there was no filtering, this code would still separate into different lines.
:::

```{r}
#| label: fig-grouped-densityplot
#| fig-cap: "An example of a grouped density plot."
# GROUPED
ggplot(diamonds %>% filter(cut %in% c("Good", "Ideal", "Premium")),
       aes(price, color = cut)) +
  geom_density() +
  labs(title = "Price Density by Cut", x = "Price", y = "Density") +
  theme(legend.position = "bottom")
```

### Boxplot - geom_boxplot() {#sec-ggplot-boxplot}

Commonly known as a box and whisker plot, boxplots are fantastic for providing numerical insights between categorical variables. There are a few different pieces of a boxplot:

-   Whiskers: there are two whiskers on each boxplot
    -   Lower Whisker: shows the lower 25% of the data. The bottom is the lowest value in the dataset
    -   Upper Whisker: shows the upper 25% of the data. The top is the highest value in the dataset
-   Box: the box itself shows the middle 50% of the data. This includes:
    -   Interquartile Range (IQR): the lowest line in the bar is the 25th percentile and the top is the 75th percentile
    -   Median: the darker line inside of the box
-   Outliers: any data point that is above or below the upper and lower whisker, respectively.

The geometry for a boxplot is `geom_boxplot()`.

```{r}
#| label: fig-basic-boxplot
#| fig-cap: "An example of a basic boxplot."
# BASIC
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_boxplot() +
  labs(title = "Highway MPG by Vehicle Class", x = "Vehicle Class", y = "Highway MPG")
```

Sometimes the points on a boxplot (or any plot) can be indistinguishable due to them being so close together. In that case, utilize the `geom_jitter()` command.

```{r}
#| label: fig-jittered-boxplot
#| fig-cap: "An example of a boxplot with jittered points."
# WITH JITTERED POINTS OVERLAID
ggplot(mpg, aes(class, hwy)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.15, alpha = 0.4, size = 1.5) +
  coord_flip() +
  labs(title = "Highway MPG by Vehicle Class (with Points)",
       x = "", y = "Highway MPG")
```

### Lines (time series) - geom_line() {#sec-ggplot-line}

Time and time again, when working with time-series data, a line graph is created. The geometry for a line graph is `geom_line()`.

```{r}
#| label: fig-basic-linegraph
#| fig-cap: "An example of a basic line graph."
# BASIC: unemployment over time
ggplot(economics, aes(x = date, y = unemploy)) +
  geom_line() +
  labs(title = "US Unemployment Over Time",
       x = "Date", y = "Number Unemployed (thousands)")
```

Like in the scatterplot, you can add a line of best fit.

```{r}
#| label: fig-lm-linegraph
#| fig-cap: "An example of line graph with a LM line of best fit."
# PLUS: LM vs LOESS contrast
ggplot(economics, aes(date, unemploy)) +
  geom_line(linewidth = 1.6) +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  labs(title = "US Unemployment with Linear Trend",
       x = "Date", y = "Number Unemployed (thousands)")
```

Instead of using "lm" for our method, let's try "loess" and see our results.

```{r}
#| label: fig-loess-linegraph
#| fig-cap: "An example of line graph with a LM line of best fit."
ggplot(economics, aes(date, unemploy)) +
  geom_line(linewidth = 0.6) +
  geom_smooth(method = "loess", se = TRUE) +  # loess = flexible smoothing; se = confidence band
  labs(title = "US Unemployment with LOESS Smooth",
       x = "Date", y = "Number Unemployed (thousands)")
```

### Put text on the plot - geom_text() {#sec-ggplot-text}

No matter the type of plot, it may help the viewer understand your plot better if you add labels to some of your data points, for example, the most extreme. To do this, utilize the `geom_text()` command.

```{r}
#| label: fig-basic-textplot
#| fig-cap: "An example of adding text inside a plot."
# BASIC: label extreme points
mpg_extremes <- mpg %>% slice_max(order_by = hwy, n = 5)
mpg_extremes
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_text(data = mpg_extremes, aes(label = model), nudge_y = 1, size = 3) +
  labs(title = "Top Highway MPG Models Labeled",
       x = "Engine Displacement (L)", y = "Highway MPG")
```

The code above first identifies the top three hwy values using `slice_max()`, pairs that with `geom_text()` and labels only the extreme data points. Now, viewers can read from the plot which model of cars have the best highway miles per gallon.

### Error bars (requires summary stats) - geom_errorbar() {#sec-ggplot-errorbar}

In times where you want error bars to be displayed, you first need to compute the mean and standard error for your values.

```{r}
#| label: tbl-computing-standard-error
#| tbl-cap: "Creating a summarized table for mean and standard error, which will be utilized for the error bars."
# Compute mean & standard error for hwy by class
summ_hwy <- mpg %>%
  group_by(class) %>%
  summarize(
    mean_hwy = mean(hwy, na.rm = TRUE),
    se_hwy   = sd(hwy, na.rm = TRUE) / sqrt(n()))

summ_hwy
```

Once completed, you can utilize the `geom_errorbar()` command to add error bars to your plot.

```{r}
#| label: fig-basic-error-plot
#| fig-cap: "An example of a plot with error bars."
# Points + error bars (plot error bars first so points sit on top)
ggplot(summ_hwy, aes(class, mean_hwy)) +
  geom_errorbar(aes(ymin = mean_hwy - se_hwy, ymax = mean_hwy + se_hwy), width = 0.2) +
  geom_point(size = 2) +
  coord_flip() +
  labs(title = "Mean Highway MPG (Â± SE) by Class", x = "", y = "Mean Highway MPG")
```

### Reference lines {#sec-ggplot-ref-lines}

Let's say there is a scenario where you are looking for data above and below a particular threshold. In this case, reference lines can become an essential tool for yourself and your viewers. Once the threshold is established (mean, median, really any number of significance to you), you can utilize the `geom_hline()` or the `geom_vline()` commands to create horizontal or vertical reference lines, respectively.

```{r}
#| label: fig-horizontal-referencelines
#| fig-cap: "An example of plot with a horizontal reference line."
# Horizontal line at overall mean
overall_mean <- mean(mpg$hwy, na.rm = TRUE)

ggplot(mpg, aes(displ, hwy)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = overall_mean, linetype = "dashed") +
  labs(title = "Reference Line at Overall Mean Highway MPG",
       x = "Engine Displacement (L)", y = "Highway MPG")
```

```{r}
#| label: fig-vertical-referencelines
#| fig-cap: "An example of plot with a vertical reference line."
# Vertical line at displ = 3
ggplot(mpg, aes(displ, hwy)) +
  geom_point(alpha = 0.6) +
  geom_vline(xintercept = 3, linetype = "dotted") +
  labs(title = "Reference Line at Engine Displacement = 3L",
       x = "Engine Displacement (L)", y = "Highway MPG")
```

## Key Takeaways {#sec-ggplot-takeaways}

-   **Always visualize your data**! Summary statistics can hide patterns (and problems) in your data.
-   `ggplot2` follows a consistent grammar: data + aesthetics + geometry.
-   `geom_bar()` counts rows automatically; `geom_col()` plots pre-summarized values.
-   Use `labs()`, `theme()`, and `coord_flip()` to improve clarity and readability.
-   `facet_wrap()` helps compare groups by creating small multiples.
-   Trend lines (`geom_smooth()`), error bars (`geom_errorbar()`), labels (`geom_text()`), and reference lines (`geom_hline()`, `geom_vline()`) help communicate the story in your data.

## Checklist {#sec-ggplot-checklist}

**When creating a visualization, have you:**

-   [ ] Started by visualizing your data (not relying only on summary statistics)?
-   [ ] Chosen a plot type that matches your goal?
-   [ ] Confirmed whether your data are raw counts (`geom_bar()`) or pre-summarized values (`geom_col()`)?
-   [ ] Clearly defined aesthetics (`x`, `y`, `color`, `shape`, `fill`) and mapped them intentionally?
-   [ ] Added informative labels using `labs()` (title, axes, legend)?
-   [ ] Adjusted the layout for readability (e.g., `coord_flip()`, `facet_wrap()`)?
-   [ ] Considered whether trend lines, error bars, labels, or reference lines would help communicate the story?
-   [ ] Checked that the visualization is interpretable *without* additional explanation?
-   [ ] Asked: *What question does this plot help answer?*

## ggplot2 Visualization Reference {#sec-ggplot-keyfunctions}

Unlike other chapters, visualization relies on combining multiple components rather than calling single functions. This section serves as a reference for common geometries, aesthetics, and commands used throughout the book.

### Summary of ggplot Geometries {#sec-ggplot-geometries}

Below is a list of plot types, their purpose, and the geom command used:

-   *Scatterplot* - **Relationships** - `geom_point()`
-   *Bar Chart* - **Counts** - `geom_bar()`
-   *Column Chart* - **Pre-summarized values** - `geom_col()`
-   *Histogram* - **Distribution** - `geom_histogram()`
-   *Density Plot* - **Distribution** - `geom_density()`
-   *Boxplot* - **Group comparison** - `geom_boxplot()`
-   *Line Graph* - **Time** - `geom_line()`

### Summary of other ggplot commands {#sec-ggplot-commands}

Below is a list of other commands used to alter plots:

-   Aesthetics:
    -   `color`: Changes the color of the points.
    -   `shape`: Changes the shape of the points.
    -   `alpha`: Changes the opacity of the point.
    -   `size`: Changes the size of the point.
    -   `fill`: Controls the interior color of shapes
-   `labs()`: Creates labels, including title, x-axis, and y-axis.
-   `facet_wrap()`: Creates individual plots and puts it into one graphic.
-   `coord_flip()`: Flips the axes without changing the underlying variables.
-   `theme()`: Controls the overall appearance of the plot
-   `theme_minimal()`: Makes the most basic looking plot.
-   `theme(legend.position = "...")`: Dictates where (if at all) the legend appears on the plot.
-   `geom_text()`: Adds text to the data points within the plot.
-   `geom_hline()`: Adds a horizontal reference line.
-   `geom_vline()`: Adds a vertical reference line.
-   `geom_smooth()`: Adds trend lines.
-   `reorder()`: Reorders categorical variables based on the values of another variable.

## ðŸ’¡ *Reproducibility Tip:* {#sec-viz-tip}

With visualizations (especially in R) there are nearly limitless possibilities. To support reproducibility, aim to create figures that clearly communicate their purpose *even when viewed on their own*.

When creating a visualization, ask yourself:

1.  What question is this visualization answering?
2.  What do I want my audience to understand from it?
3.  What would someone understand if they saw this figure without any surrounding text?

To help close the gap between these questions, use informative labels and captions, that will help *guide* users on what they're seeing.

Within `ggplot2`, functions like `labs()` allow you to clearly label axes, titles, and legends so the intent of the plot is immediately clear. When working in R Markdown or bookdown (@sec-r-markdown-graphs), figure captions (using `fig-cap`) provide additional context that travels with the figure wherever it appears.

Visualizations that are well-labeled and properly captioned are easier to interpret, reuse, and reproduceâ€”both by others and by your future self.
